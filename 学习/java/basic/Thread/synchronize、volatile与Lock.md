### synchronized
* `synchronized`是`java`中的关键字，是一种同步锁。

* 作用
  * 被`synchronized`修饰的方法或代码块在运行时，同一时刻，最多只有一个线程执行这段代码。

* 修饰对象
  * 代码块
  * 非静态方法
  * 静态方法

* 注意
  * `synchronized`修饰代码块，锁对象是某个类的`class`对象,这个类的所有实例共用一把锁。
  * `synchronized`修饰静态方法时，调用这个静态方法的所有实例共用一把锁。
  * `synchronized`关键字继承无效，即子类重写父类的同步方法，如果子类的这个方法不加`synchronized`修饰，则子类的这个方法不是同步方法。
  * 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。
---

### volatile
* `volatile`是`java`中的关键字。

* 作用
  * 保证不同线程对`volatile`修饰的变量进行操作时的可见性，即一个线程修改了变量的值，这个新值对其他线程来说是可见的。
    在`java`中，为了加快程序的运行效率对一些变量的操作通常是在该线程的寄存器或是CPU缓存上进行的，之后才同步到主存中，而加了`volatile`修饰符的变量则是直接读写主存。

  * 禁止进行指令重排序

    处理器为了提高程序允许效率，可能会对输入的代码进行优化，它不保证各个语句的执行顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。程序执行到`volatile`修饰变量的读写时，在其前面的操作肯定已经完成，且结果已经对后面的操作可见，在其后面的操作肯定还没有执行。

* 修饰对象
  * 类的成员变量（包括静态的和非静态的）


---

### Lock
* `Lock` 是`java.util.concurrent.locks`包下的接口，可以用来实现同步访问。
* ​


---
### 比较

#### volatile和synchronized比较

* `volatile` 性能要优于`synchronized`，但无法保证操作的原子性（要么不执行， 要么全部执行）。
* `synchronized`可以保证可见性和原子性（因为同一时刻只有一个线程在执行），但性能不高。

#### synchronized和Lock比较
* `synchronized`是`java`关键字，而`Lock`是一个接口，且`Lock`比`synchronized`提供了更多的功能。
* `synchronized`可以自动释放锁，而`Lock`需要手动释放锁。因此发生异常时，`Lock`需要在finally块中释放锁。
* `Lock`可以让等待锁的线程响应中断，而`synchronized`只能让线程一直等待下去。
* `Lock`可以知道线程有没有成功获取到锁，而`synchronized`不能。
* `Lock`可以提高多个线程进行读操作的效率。
